'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@opentelemetry/api');
var core = require('@opentelemetry/core');
var url = require('url');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var fs = require('fs');
var os = require('os');
var path = require('path');
var child_process = require('child_process');
var util = require('util');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var sdkMetricsBase = require('@opentelemetry/sdk-metrics-base');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var url__default = /*#__PURE__*/_interopDefaultLegacy(url);
var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var os__namespace = /*#__PURE__*/_interopNamespace(os);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var child_process__namespace = /*#__PURE__*/_interopNamespace(child_process);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure service API version.
 */
exports.ServiceApiVersion = void 0;
(function (ServiceApiVersion) {
    /**
     * V2 Version
     */
    ServiceApiVersion["V2"] = "2020-09-15_Preview";
})(exports.ServiceApiVersion || (exports.ServiceApiVersion = {}));
/**
 * Default Breeze endpoint.
 * @internal
 */
const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
/**
 * Default Breeze API version.
 * @internal
 */
const DEFAULT_BREEZE_API_VERSION = exports.ServiceApiVersion.V2;
/**
 * Default Live Metrics endpoint.
 * @internal
 */
const DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
/**
 * Connection string environment variable name.
 * @internal
 */
const ENV_CONNECTION_STRING = "APPLICATIONINSIGHTS_CONNECTION_STRING";
/**
 * QuickPulse metric counter names.
 * @internal
 */
var QuickPulseCounter;
(function (QuickPulseCounter) {
    // Memory
    QuickPulseCounter["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // CPU
    QuickPulseCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // Request
    QuickPulseCounter["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseCounter["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseCounter["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseCounter["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseCounter["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseCounter["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseCounter["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseCounter || (QuickPulseCounter = {}));
/**
 * Performance metric counter names.
 * @internal
 */
var PerformanceCounter;
(function (PerformanceCounter) {
    // Memory
    PerformanceCounter["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounter["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    // CPU
    PerformanceCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounter["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    // Requests
    PerformanceCounter["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounter["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounter || (PerformanceCounter = {}));
/**
 * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*
 * @internal
 */
({
    [PerformanceCounter.PROCESSOR_TIME]: QuickPulseCounter.PROCESSOR_TIME,
    [PerformanceCounter.REQUEST_RATE]: QuickPulseCounter.REQUEST_RATE,
    [PerformanceCounter.REQUEST_DURATION]: QuickPulseCounter.REQUEST_DURATION,
    // Remap quick pulse only counters
    [QuickPulseCounter.COMMITTED_BYTES]: QuickPulseCounter.COMMITTED_BYTES,
    [QuickPulseCounter.REQUEST_FAILURE_RATE]: QuickPulseCounter.REQUEST_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_RATE]: QuickPulseCounter.DEPENDENCY_RATE,
    [QuickPulseCounter.DEPENDENCY_FAILURE_RATE]: QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_DURATION]: QuickPulseCounter.DEPENDENCY_DURATION,
    [QuickPulseCounter.EXCEPTION_RATE]: QuickPulseCounter.EXCEPTION_RATE,
});

// Copyright (c) Microsoft Corporation.
/**
 * ConnectionString parser.
 * @internal
 */
class ConnectionStringParser {
    static parse(connectionString) {
        if (!connectionString) {
            return {};
        }
        const kvPairs = connectionString.split(ConnectionStringParser.FIELDS_SEPARATOR);
        let isValid = true;
        const result = kvPairs.reduce((fields, kv) => {
            const kvParts = kv.split(ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
                // only save fields with valid formats
                const key = kvParts[0].toLowerCase();
                const value = kvParts[1];
                return Object.assign(Object.assign({}, fields), { [key]: value });
            }
            api.diag.error(`Connection string key-value pair is invalid: ${kv}`, `Entire connection string will be discarded`, connectionString);
            isValid = false;
            return fields;
        }, {});
        if (isValid && Object.keys(result).length > 0) {
            // this is a valid connection string, so parse the results
            if (result.endpointsuffix) {
                // use endpoint suffix where overrides are not provided
                const locationPrefix = result.location ? `${result.location}.` : "";
                result.ingestionendpoint =
                    result.ingestionendpoint || `https://${locationPrefix}dc.${result.endpointsuffix}`;
                result.liveendpoint =
                    result.liveendpoint || `https://${locationPrefix}live.${result.endpointsuffix}`;
            }
            result.ingestionendpoint = result.ingestionendpoint
                ? ConnectionStringParser.sanitizeUrl(result.ingestionendpoint)
                : DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint
                ? ConnectionStringParser.sanitizeUrl(result.liveendpoint)
                : DEFAULT_LIVEMETRICS_ENDPOINT;
            if (result.authorization && result.authorization.toLowerCase() !== "ikey") {
                api.diag.warn(`Connection String contains an unsupported 'Authorization' value: ${result.authorization}. Defaulting to 'Authorization=ikey'. Instrumentation Key ${result.instrumentationkey}`);
            }
        }
        else {
            api.diag.error("An invalid connection string was passed in. There may be telemetry loss", connectionString);
        }
        return result;
    }
    static sanitizeUrl(url) {
        let newUrl = url.trim();
        if (newUrl.indexOf("https://") < 0) {
            // Try to update http to https
            newUrl = newUrl.replace("http://", "https://");
        }
        // Remove final slash if present
        if (newUrl[newUrl.length - 1] == "/") {
            newUrl = newUrl.slice(0, -1);
        }
        return newUrl;
    }
}
ConnectionStringParser.FIELDS_SEPARATOR = ";";
ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR = "=";

const DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS = 60000;
const DEFAULT_MAX_CONSECUTIVE_FAILURES_BEFORE_WARNING = 10;
/**
 * Internal default Azure exporter configuration
 * @internal
 */
const DEFAULT_EXPORTER_CONFIG = {
    instrumentationKey: "",
    endpointUrl: DEFAULT_BREEZE_ENDPOINT,
    batchSendRetryIntervalMs: DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS,
    maxConsecutiveFailuresBeforeWarning: DEFAULT_MAX_CONSECUTIVE_FAILURES_BEFORE_WARNING,
    apiVersion: DEFAULT_BREEZE_API_VERSION,
};

// Copyright (c) Microsoft Corporation.
class FileAccessControl {
    // Check if file access control could be enabled
    static checkFileProtection() {
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION &&
            !FileAccessControl.OS_FILE_PROTECTION_CHECKED) {
            FileAccessControl.OS_FILE_PROTECTION_CHECKED = true;
            // Node's chmod levels do not appropriately restrict file access on Windows
            // Use the built-in command line tool ICACLS on Windows to properly restrict
            // access to the temporary directory used for disk retry mode.
            if (FileAccessControl.USE_ICACLS) {
                // This should be async - but it's currently safer to have this synchronous
                // This guarantees we can immediately fail setDiskRetryMode if we need to
                try {
                    FileAccessControl.OS_PROVIDES_FILE_PROTECTION = fs__namespace.existsSync(FileAccessControl.ICACLS_PATH);
                }
                catch (e) {
                    // Ignore error
                }
                if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
                    api.diag.warn("Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
                }
            }
            else {
                // chmod works everywhere else
                FileAccessControl.OS_PROVIDES_FILE_PROTECTION = true;
            }
        }
    }
    static async applyACLRules(directory) {
        if (FileAccessControl.USE_ICACLS) {
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately
                // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk
                // This is better than the alternative of potentially infinitely spawned processes
                FileAccessControl.ACLED_DIRECTORIES[directory] = false;
                try {
                    // Restrict this directory to only current user and administrator access
                    let identity = await this._getACLIdentity();
                    await this._runICACLS(this._getACLArguments(directory, identity));
                    FileAccessControl.ACLED_DIRECTORIES[directory] = true;
                }
                catch (ex) {
                    FileAccessControl.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is "not yet tried")
                    throw ex;
                }
            }
            else {
                if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                    throw new Error("Setting ACL restrictions did not succeed (cached result)");
                }
            }
        }
    }
    static applyACLRulesSync(directory) {
        if (FileAccessControl.USE_ICACLS) {
            // For performance, only run ACL rules if we haven't already during this session
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
                FileAccessControl.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures
                return;
            }
            else if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                // falsy but not undefined
                throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
        }
    }
    static _runICACLS(args) {
        return new Promise((resolve, reject) => {
            var aclProc = child_process__namespace.spawn(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            aclProc.on("error", (e) => reject(e));
            aclProc.on("close", (code) => {
                if (code === 0) {
                    resolve();
                }
                else {
                    reject(new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${code})`));
                }
            });
        });
    }
    static _runICACLSSync(args) {
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            var aclProc = child_process__namespace.spawnSync(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            if (aclProc.error) {
                throw aclProc.error;
            }
            else if (aclProc.status !== 0) {
                throw new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${aclProc.status})`);
            }
        }
        else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
    }
    static _getACLIdentity() {
        return new Promise((resolve, reject) => {
            if (FileAccessControl.ACL_IDENTITY) {
                resolve(FileAccessControl.ACL_IDENTITY);
            }
            var psProc = child_process__namespace.spawn(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            let data = "";
            psProc.stdout.on("data", (d) => (data += d));
            psProc.on("error", (e) => reject(e));
            psProc.on("close", (code) => {
                FileAccessControl.ACL_IDENTITY = data && data.trim();
                if (code === 0) {
                    resolve(FileAccessControl.ACL_IDENTITY);
                }
                else {
                    reject(new Error(`Getting ACL identity did not succeed (PS returned code ${code})`));
                }
            });
        });
    }
    static _getACLIdentitySync() {
        if (FileAccessControl.ACL_IDENTITY) {
            return FileAccessControl.ACL_IDENTITY;
        }
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            var psProc = child_process__namespace.spawnSync(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
                throw psProc.error;
            }
            else if (psProc.status !== 0) {
                throw new Error(`Getting ACL identity did not succeed (PS returned code ${psProc.status})`);
            }
            FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return FileAccessControl.ACL_IDENTITY;
        }
        else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
    }
    static _getACLArguments(directory, identity) {
        return [
            directory,
            "/grant",
            "*S-1-5-32-544:(OI)(CI)F",
            "/grant",
            `${identity}:(OI)(CI)F`,
            "/inheritance:r",
        ]; // Remove all inherited permissions
    }
}
FileAccessControl.ICACLS_PATH = `${process.env.systemdrive}/windows/system32/icacls.exe`;
FileAccessControl.POWERSHELL_PATH = `${process.env.systemdrive}/windows/system32/windowspowershell/v1.0/powershell.exe`;
FileAccessControl.ACLED_DIRECTORIES = {};
FileAccessControl.ACL_IDENTITY = null;
FileAccessControl.OS_FILE_PROTECTION_CHECKED = false;
FileAccessControl.OS_PROVIDES_FILE_PROTECTION = false;
FileAccessControl.USE_ICACLS = os__namespace.type() === "Windows_NT";

// Copyright (c) Microsoft Corporation.
const readdirAsync$1 = util.promisify(fs__namespace.readdir);
const statAsync$1 = util.promisify(fs__namespace.stat);
const lstatAsync = util.promisify(fs__namespace.lstat);
const mkdirAsync = util.promisify(fs__namespace.mkdir);
/**
 * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
 * @internal
 */
const getShallowDirectorySize = async (directory) => {
    // Get the directory listing
    const files = await readdirAsync$1(directory);
    let totalSize = 0;
    // Query all file sizes
    for (const file of files) {
        const fileStats = await statAsync$1(path__namespace.join(directory, file));
        if (fileStats.isFile()) {
            totalSize += fileStats.size;
        }
    }
    return totalSize;
};
/**
 * Validate directory exists.
 * @internal
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await lstatAsync(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                await mkdirAsync(directory);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};

// Copyright (c) Microsoft Corporation.
const statAsync = util.promisify(fs__namespace.stat);
const readdirAsync = util.promisify(fs__namespace.readdir);
const readFileAsync = util.promisify(fs__namespace.readFile);
const unlinkAsync = util.promisify(fs__namespace.unlink);
const writeFileAsync = util.promisify(fs__namespace.writeFile);
/**
 * File system persist class.
 * @internal
 */
class FileSystemPersist {
    constructor(options = {}) {
        this.fileRetemptionPeriod = 7 * 24 * 60 * 60 * 1000; // 7 days
        this.cleanupTimeOut = 60 * 60 * 1000; // 1 hour
        this.maxBytesOnDisk = 50000000; // ~50MB
        this._tempDirectory = "";
        this._fileCleanupTimer = null;
        this._options = Object.assign(Object.assign({}, DEFAULT_EXPORTER_CONFIG), options);
        this._enabled = true;
        FileAccessControl.checkFileProtection();
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
            this._enabled = false;
            api.diag.error("Sufficient file protection capabilities were not detected. Files will not be persisted");
        }
        if (!this._options.instrumentationKey) {
            this._enabled = false;
            api.diag.error(`No instrumentation key was provided to FileSystemPersister. Files will not be persisted`);
        }
        if (this._enabled) {
            this._tempDirectory = path__namespace.join(os__namespace.tmpdir(), FileSystemPersist.TEMPDIR_PREFIX + this._options.instrumentationKey);
            // Starts file cleanup task
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setTimeout(() => {
                    this._fileCleanupTask();
                }, this.cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    push(value) {
        if (this._enabled) {
            api.diag.debug("Pushing value to persistent storage", value.toString());
            return this._storeToDisk(JSON.stringify(value));
        }
        return new Promise((resolve) => {
            resolve(false);
        });
    }
    async shift() {
        if (this._enabled) {
            api.diag.debug("Searching for filesystem persisted files");
            try {
                const buffer = await this._getFirstFileOnDisk();
                if (buffer) {
                    return JSON.parse(buffer.toString("utf8"));
                }
            }
            catch (e) {
                api.diag.debug("Failed to read persisted file", e);
            }
            return null;
        }
        return new Promise((resolve) => {
            resolve(null);
        });
    }
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    async _getFirstFileOnDisk() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return null;
                }
                else {
                    const firstFile = files[0];
                    const filePath = path__namespace.join(this._tempDirectory, firstFile);
                    const payload = await readFileAsync(filePath);
                    // delete the file first to prevent double sending
                    await unlinkAsync(filePath);
                    return payload;
                }
            }
            return null;
        }
        catch (e) {
            if (e.code === "ENOENT") {
                // File does not exist -- return null instead of throwing
                return null;
            }
            else {
                throw e;
            }
        }
    }
    async _storeToDisk(payload) {
        try {
            await confirmDirExists(this._tempDirectory);
        }
        catch (error) {
            api.diag.warn(`Error while checking/creating directory: `, error && error.message);
            return false;
        }
        try {
            const size = await getShallowDirectorySize(this._tempDirectory);
            if (size > this.maxBytesOnDisk) {
                api.diag.warn(`Not saving data due to max size limit being met. Directory size in bytes is: ${size}`);
                return false;
            }
        }
        catch (error) {
            api.diag.warn(`Error while checking size of persistence directory: `, error && error.message);
            return false;
        }
        const fileName = `${new Date().getTime()}${FileSystemPersist.FILENAME_SUFFIX}`;
        const fileFullPath = path__namespace.join(this._tempDirectory, fileName);
        // Mode 600 is w/r for creator and no read access for others
        api.diag.info(`saving data to disk at: ${fileFullPath}`);
        try {
            await writeFileAsync(fileFullPath, payload, { mode: 0o600 });
        }
        catch (writeError) {
            api.diag.warn(`Error writing file to persistent file storage`, writeError);
            return false;
        }
        return true;
    }
    async _fileCleanupTask() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return false;
                }
                else {
                    files.forEach(async (file) => {
                        // Check expiration
                        const fileCreationDate = new Date(parseInt(file.split(FileSystemPersist.FILENAME_SUFFIX)[0]));
                        const expired = new Date(+new Date() - this.fileRetemptionPeriod) > fileCreationDate;
                        if (expired) {
                            const filePath = path__namespace.join(this._tempDirectory, file);
                            await unlinkAsync(filePath);
                        }
                    });
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            api.diag.info(`Failed cleanup of persistent file storage expired files`, error);
            return false;
        }
    }
}
FileSystemPersist.TEMPDIR_PREFIX = "ot-azure-exporter-";
FileSystemPersist.FILENAME_SUFFIX = ".ai.json";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DataPointType} that the service accepts. */
var KnownDataPointType;
(function (KnownDataPointType) {
    KnownDataPointType["Measurement"] = "Measurement";
    KnownDataPointType["Aggregation"] = "Aggregation";
})(KnownDataPointType || (KnownDataPointType = {}));
/** Known values of {@link SeverityLevel} that the service accepts. */
var KnownSeverityLevel;
(function (KnownSeverityLevel) {
    KnownSeverityLevel["Verbose"] = "Verbose";
    KnownSeverityLevel["Information"] = "Information";
    KnownSeverityLevel["Warning"] = "Warning";
    KnownSeverityLevel["Error"] = "Error";
    KnownSeverityLevel["Critical"] = "Critical";
})(KnownSeverityLevel || (KnownSeverityLevel = {}));
/** Known values of {@link ContextTagKeys} that the service accepts. */
var KnownContextTagKeys;
(function (KnownContextTagKeys) {
    KnownContextTagKeys["AiApplicationVer"] = "ai.application.ver";
    KnownContextTagKeys["AiDeviceId"] = "ai.device.id";
    KnownContextTagKeys["AiDeviceLocale"] = "ai.device.locale";
    KnownContextTagKeys["AiDeviceModel"] = "ai.device.model";
    KnownContextTagKeys["AiDeviceOemName"] = "ai.device.oemName";
    KnownContextTagKeys["AiDeviceOsVersion"] = "ai.device.osVersion";
    KnownContextTagKeys["AiDeviceType"] = "ai.device.type";
    KnownContextTagKeys["AiLocationIp"] = "ai.location.ip";
    KnownContextTagKeys["AiLocationCountry"] = "ai.location.country";
    KnownContextTagKeys["AiLocationProvince"] = "ai.location.province";
    KnownContextTagKeys["AiLocationCity"] = "ai.location.city";
    KnownContextTagKeys["AiOperationId"] = "ai.operation.id";
    KnownContextTagKeys["AiOperationName"] = "ai.operation.name";
    KnownContextTagKeys["AiOperationParentId"] = "ai.operation.parentId";
    KnownContextTagKeys["AiOperationSyntheticSource"] = "ai.operation.syntheticSource";
    KnownContextTagKeys["AiOperationCorrelationVector"] = "ai.operation.correlationVector";
    KnownContextTagKeys["AiSessionId"] = "ai.session.id";
    KnownContextTagKeys["AiSessionIsFirst"] = "ai.session.isFirst";
    KnownContextTagKeys["AiUserAccountId"] = "ai.user.accountId";
    KnownContextTagKeys["AiUserId"] = "ai.user.id";
    KnownContextTagKeys["AiUserAuthUserId"] = "ai.user.authUserId";
    KnownContextTagKeys["AiCloudRole"] = "ai.cloud.role";
    KnownContextTagKeys["AiCloudRoleVer"] = "ai.cloud.roleVer";
    KnownContextTagKeys["AiCloudRoleInstance"] = "ai.cloud.roleInstance";
    KnownContextTagKeys["AiCloudLocation"] = "ai.cloud.location";
    KnownContextTagKeys["AiInternalSdkVersion"] = "ai.internal.sdkVersion";
    KnownContextTagKeys["AiInternalAgentVersion"] = "ai.internal.agentVersion";
    KnownContextTagKeys["AiInternalNodeName"] = "ai.internal.nodeName";
})(KnownContextTagKeys || (KnownContextTagKeys = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: {
        serializedName: "body",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "TelemetryItem"
                }
            }
        }
    }
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const host = {
    parameterPath: "host",
    mapper: {
        serializedName: "Host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const TelemetryItem = {
    type: {
        name: "Composite",
        className: "TelemetryItem",
        modelProperties: {
            version: {
                defaultValue: 1,
                serializedName: "ver",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            time: {
                serializedName: "time",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            sampleRate: {
                defaultValue: 100,
                serializedName: "sampleRate",
                type: {
                    name: "Number"
                }
            },
            sequence: {
                constraints: {
                    MaxLength: 64
                },
                serializedName: "seq",
                type: {
                    name: "String"
                }
            },
            instrumentationKey: {
                serializedName: "iKey",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Composite",
                    className: "MonitorBase"
                }
            }
        }
    }
};
const MonitorBase = {
    type: {
        name: "Composite",
        className: "MonitorBase",
        modelProperties: {
            baseType: {
                serializedName: "baseType",
                type: {
                    name: "String"
                }
            },
            baseData: {
                serializedName: "baseData",
                type: {
                    name: "Composite",
                    className: "MonitorDomain"
                }
            }
        }
    }
};
const MonitorDomain = {
    type: {
        name: "Composite",
        className: "MonitorDomain",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            version: {
                defaultValue: 2,
                serializedName: "ver",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TrackResponse = {
    type: {
        name: "Composite",
        className: "TrackResponse",
        modelProperties: {
            itemsReceived: {
                serializedName: "itemsReceived",
                type: {
                    name: "Number"
                }
            },
            itemsAccepted: {
                serializedName: "itemsAccepted",
                type: {
                    name: "Number"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryErrorDetails"
                        }
                    }
                }
            }
        }
    }
};
const TelemetryErrorDetails = {
    type: {
        name: "Composite",
        className: "TelemetryErrorDetails",
        modelProperties: {
            index: {
                serializedName: "index",
                type: {
                    name: "Number"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricDataPoint = {
    type: {
        name: "Composite",
        className: "MetricDataPoint",
        modelProperties: {
            namespace: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "ns",
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataPointType: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            },
            count: {
                serializedName: "count",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            min: {
                serializedName: "min",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            stdDev: {
                serializedName: "stdDev",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TelemetryExceptionDetails = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number"
                }
            },
            outerId: {
                serializedName: "outerId",
                type: {
                    name: "Number"
                }
            },
            typeName: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            },
            message: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            hasFullStack: {
                defaultValue: true,
                serializedName: "hasFullStack",
                type: {
                    name: "Boolean"
                }
            },
            stack: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "stack",
                type: {
                    name: "String"
                }
            },
            parsedStack: {
                serializedName: "parsedStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackFrame"
                        }
                    }
                }
            }
        }
    }
};
const StackFrame = {
    type: {
        name: "Composite",
        className: "StackFrame",
        modelProperties: {
            level: {
                serializedName: "level",
                required: true,
                type: {
                    name: "Number"
                }
            },
            method: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "method",
                required: true,
                type: {
                    name: "String"
                }
            },
            assembly: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "assembly",
                type: {
                    name: "String"
                }
            },
            fileName: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "fileName",
                type: {
                    name: "String"
                }
            },
            line: {
                serializedName: "line",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AvailabilityData = {
    type: {
        name: "Composite",
        className: "AvailabilityData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, runLocation: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "runLocation",
                type: {
                    name: "String"
                }
            }, message: {
                constraints: {
                    MaxLength: 8192
                },
                serializedName: "message",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const TelemetryEventData = {
    type: {
        name: "Composite",
        className: "TelemetryEventData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const TelemetryExceptionData = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { exceptions: {
                serializedName: "exceptions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryExceptionDetails"
                        }
                    }
                }
            }, severityLevel: {
                serializedName: "severityLevel",
                nullable: true,
                type: {
                    name: "String"
                }
            }, problemId: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "problemId",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const MessageData = {
    type: {
        name: "Composite",
        className: "MessageData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { message: {
                constraints: {
                    MaxLength: 32768
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }, severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const MetricsData = {
    type: {
        name: "Composite",
        className: "MetricsData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { metrics: {
                serializedName: "metrics",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDataPoint"
                        }
                    }
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            } })
    }
};
const PageViewData = {
    type: {
        name: "Composite",
        className: "PageViewData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }, referredUri: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "referredUri",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const PageViewPerfData = {
    type: {
        name: "Composite",
        className: "PageViewPerfData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String"
                }
            }, perfTotal: {
                serializedName: "perfTotal",
                type: {
                    name: "String"
                }
            }, networkConnect: {
                serializedName: "networkConnect",
                type: {
                    name: "String"
                }
            }, sentRequest: {
                serializedName: "sentRequest",
                type: {
                    name: "String"
                }
            }, receivedResponse: {
                serializedName: "receivedResponse",
                type: {
                    name: "String"
                }
            }, domProcessing: {
                serializedName: "domProcessing",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const RemoteDependencyData = {
    type: {
        name: "Composite",
        className: "RemoteDependencyData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, resultCode: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "resultCode",
                type: {
                    name: "String"
                }
            }, data: {
                constraints: {
                    MaxLength: 8192
                },
                serializedName: "data",
                type: {
                    name: "String"
                }
            }, type: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, target: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "target",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                defaultValue: true,
                serializedName: "success",
                type: {
                    name: "Boolean"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const RequestData = {
    type: {
        name: "Composite",
        className: "RequestData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }, name: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String"
                }
            }, success: {
                defaultValue: true,
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean"
                }
            }, responseCode: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "responseCode",
                required: true,
                type: {
                    name: "String"
                }
            }, source: {
                constraints: {
                    MaxLength: 1024
                },
                serializedName: "source",
                type: {
                    name: "String"
                }
            }, url: {
                constraints: {
                    MaxLength: 2048
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } }
                }
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TelemetryItem: TelemetryItem,
    MonitorBase: MonitorBase,
    MonitorDomain: MonitorDomain,
    TrackResponse: TrackResponse,
    TelemetryErrorDetails: TelemetryErrorDetails,
    MetricDataPoint: MetricDataPoint,
    TelemetryExceptionDetails: TelemetryExceptionDetails,
    StackFrame: StackFrame,
    AvailabilityData: AvailabilityData,
    TelemetryEventData: TelemetryEventData,
    TelemetryExceptionData: TelemetryExceptionData,
    MessageData: MessageData,
    MetricsData: MetricsData,
    PageViewData: PageViewData,
    PageViewPerfData: PageViewPerfData,
    RemoteDependencyData: RemoteDependencyData,
    RequestData: RequestData
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ApplicationInsightsClientContext extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ApplicationInsightsClientContext class.
     * @param options The parameter options
     */
    constructor(options) {
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-monitor-opentelemetry-exporter/1.0.0-beta.7`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "{Host}/v2.1" });
        super(optionsWithDefaults);
        // Assigning values to Constant parameters
        this.host = options.host || "https://dc.services.visualstudio.com";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ApplicationInsightsClient extends ApplicationInsightsClientContext {
    /**
     * Initializes a new instance of the ApplicationInsightsClient class.
     * @param options The parameter options
     */
    constructor(options) {
        super(options);
    }
    /**
     * This operation sends a sequence of telemetry events that will be monitored by Azure Monitor.
     * @param body The list of telemetry events to track.
     * @param options The options parameters.
     */
    track(body, options) {
        return this.sendOperationRequest({ body, options }, trackOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const trackOperationSpec = {
    path: "/track",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TrackResponse
        },
        206: {
            bodyMapper: TrackResponse
        },
        400: {
            bodyMapper: TrackResponse,
            isError: true
        },
        402: {
            bodyMapper: TrackResponse,
            isError: true
        },
        429: {
            bodyMapper: TrackResponse,
            isError: true
        },
        500: {
            bodyMapper: TrackResponse,
            isError: true
        },
        503: {
            bodyMapper: TrackResponse,
            isError: true
        }
    },
    requestBody: body,
    urlParameters: [host],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
const applicationInsightsResource = "https://monitor.azure.com//.default";
/**
 * Exporter HTTP sender class
 * @internal
 */
class HttpSender {
    constructor(_exporterOptions) {
        this._exporterOptions = _exporterOptions;
        // Build endpoint using provided configuration or default values
        this._appInsightsClientOptions = {
            host: this._exporterOptions.endpointUrl,
        };
        this._appInsightsClient = new ApplicationInsightsClient(Object.assign({}, this._appInsightsClientOptions));
        // Handle redirects in HTTP Sender
        this._appInsightsClient.pipeline.removePolicy({ name: coreRestPipeline.redirectPolicyName });
        if (this._exporterOptions.aadTokenCredential) {
            let scopes = [applicationInsightsResource];
            this._appInsightsClient.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: this._exporterOptions.aadTokenCredential,
                scopes: scopes,
            }));
        }
    }
    /**
     * Send Azure envelopes
     * @internal
     */
    async send(envelopes) {
        var _a;
        let options = {};
        try {
            let response;
            function onResponse(rawResponse, flatResponse) {
                response = rawResponse;
                if (options.onResponse) {
                    options.onResponse(rawResponse, flatResponse);
                }
            }
            await this._appInsightsClient.track(envelopes, Object.assign(Object.assign({}, options), { onResponse }));
            return { statusCode: response === null || response === void 0 ? void 0 : response.status, result: (_a = response === null || response === void 0 ? void 0 : response.bodyAsText) !== null && _a !== void 0 ? _a : "" };
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Shutdown sender
     * @internal
     */
    async shutdown() {
        api.diag.info("HttpSender shutting down");
    }
    handlePermanentRedirect(location) {
        if (location) {
            const locUrl = new url__default["default"].URL(location);
            if (locUrl && locUrl.host) {
                this._appInsightsClient.host = "https://" + locUrl.host;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * AI MS Links.
 * @internal
 */
const MS_LINKS = "_MS.links";
/**
 * AI enqueued time attribute.
 * @internal
 */
const ENQUEUED_TIME = "enqueuedTime";
/**
 * AI time since enqueued attribute.
 * @internal
 */
const TIME_SINCE_ENQUEUED = "timeSinceEnqueued";
/**
 * AzureMonitorTraceExporter version.
 * @internal
 */
const packageVersion = "1.0.0-beta.8";
var DependencyTypes;
(function (DependencyTypes) {
    DependencyTypes["InProc"] = "InProc";
    DependencyTypes["QueueMessage"] = "Queue Message";
    DependencyTypes["Sql"] = "SQL";
    DependencyTypes["Http"] = "Http";
    DependencyTypes["Grpc"] = "GRPC";
})(DependencyTypes || (DependencyTypes = {}));

// Copyright (c) Microsoft Corporation.
let instance = null;
/**
 * Azure Telemetry context.
 * @internal
 */
class Context {
    constructor() {
        this.tags = {};
        this._loadDeviceContext();
        this._loadInternalContext();
    }
    _loadDeviceContext() {
        this.tags[KnownContextTagKeys.AiDeviceOsVersion] = os__namespace && `${os__namespace.type()} ${os__namespace.release()}`;
    }
    _loadInternalContext() {
        const { node } = process.versions;
        [Context.nodeVersion] = node.split(".");
        Context.opentelemetryVersion = core.SDK_INFO[semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_VERSION];
        Context.sdkVersion = packageVersion;
        this.tags[KnownContextTagKeys.AiInternalSdkVersion] = `node${Context.nodeVersion}:otel${Context.opentelemetryVersion}:ext${Context.sdkVersion}`;
    }
}
Context.sdkVersion = null;
Context.opentelemetryVersion = null;
Context.nodeVersion = "";
/**
 * Singleton Context instance.
 * @internal
 */
function getInstance() {
    if (!instance) {
        instance = new Context();
    }
    return instance;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Breeze retriable status codes.
 * @internal
 */
function isRetriable(statusCode) {
    return (statusCode === 206 || // Partial Accept
        statusCode === 401 || // Unauthorized
        statusCode === 403 || // Forbidden
        statusCode === 408 || // Timeout
        statusCode === 429 || // Too many requests
        statusCode === 500 || // Server Error
        statusCode === 503 // Server Unavailable
    );
}
/**
 * Convert milliseconds to Breeze expected time.
 * @internal
 */
function msToTimeSpan(ms) {
    let totalms = ms;
    if (Number.isNaN(totalms) || totalms < 0 || !Number.isFinite(ms)) {
        totalms = 0;
    }
    let sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, "");
    let min = `${Math.floor(totalms / (1000 * 60)) % 60}`;
    let hour = `${Math.floor(totalms / (1000 * 60 * 60)) % 24}`;
    const days = Math.floor(totalms / (1000 * 60 * 60 * 24));
    sec = sec.indexOf(".") < 2 ? `0${sec}` : sec;
    min = min.length < 2 ? `0${min}` : min;
    hour = hour.length < 2 ? `0${hour}` : hour;
    const daysText = days > 0 ? `${days}.` : "";
    return `${daysText + hour}:${min}:${sec}`;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorBaseExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        var _a, _b, _c, _d;
        this._numConsecutiveRedirects = 0;
        const connectionString = options.connectionString || process.env[ENV_CONNECTION_STRING];
        this._options = Object.assign({}, DEFAULT_EXPORTER_CONFIG);
        this._options.apiVersion = (_a = options.apiVersion) !== null && _a !== void 0 ? _a : this._options.apiVersion;
        this._options.aadTokenCredential = options.aadTokenCredential;
        if (connectionString) {
            const parsedConnectionString = ConnectionStringParser.parse(connectionString);
            this._options.instrumentationKey =
                (_b = parsedConnectionString.instrumentationkey) !== null && _b !== void 0 ? _b : this._options.instrumentationKey;
            this._options.endpointUrl =
                (_d = (_c = parsedConnectionString.ingestionendpoint) === null || _c === void 0 ? void 0 : _c.trim()) !== null && _d !== void 0 ? _d : this._options.endpointUrl;
        }
        // Instrumentation key is required
        if (!this._options.instrumentationKey) {
            const message = "No instrumentation key or connection string was provided to the Azure Monitor Exporter";
            api.diag.error(message);
            throw new Error(message);
        }
        this._instrumentationKey = this._options.instrumentationKey;
        this._sender = new HttpSender(this._options);
        this._persister = new FileSystemPersist(this._options);
        this._retryTimer = null;
        api.diag.debug("AzureMonitorTraceExporter was successfully setup");
    }
    /**
     * Persist envelopes to disk
     */
    async _persist(envelopes) {
        try {
            const success = await this._persister.push(envelopes);
            return success
                ? { code: core.ExportResultCode.SUCCESS }
                : {
                    code: core.ExportResultCode.FAILED,
                    error: new Error("Failed to persist envelope in disk."),
                };
        }
        catch (ex) {
            return { code: core.ExportResultCode.FAILED, error: ex };
        }
    }
    /**
     * Shutdown exporter
     */
    async _shutdown() {
        return this._sender.shutdown();
    }
    /**
     * Export envelopes
     */
    async _exportEnvelopes(envelopes) {
        api.diag.info(`Exporting ${envelopes.length} envelope(s)`);
        try {
            const { result, statusCode } = await this._sender.send(envelopes);
            this._numConsecutiveRedirects = 0;
            if (statusCode === 200) {
                // Success -- @todo: start retry timer
                if (!this._retryTimer) {
                    this._retryTimer = setTimeout(() => {
                        this._retryTimer = null;
                        this._sendFirstPersistedFile();
                    }, this._options.batchSendRetryIntervalMs);
                    this._retryTimer.unref();
                }
                return { code: core.ExportResultCode.SUCCESS };
            }
            else if (statusCode && isRetriable(statusCode)) {
                // Failed -- persist failed data
                if (result) {
                    api.diag.info(result);
                    const breezeResponse = JSON.parse(result);
                    const filteredEnvelopes = [];
                    if (breezeResponse.errors) {
                        breezeResponse.errors.forEach((error) => {
                            if (error.statusCode && isRetriable(error.statusCode)) {
                                filteredEnvelopes.push(envelopes[error.index]);
                            }
                        });
                    }
                    if (filteredEnvelopes.length > 0) {
                        // calls resultCallback(ExportResult) based on result of persister.push
                        return await this._persist(filteredEnvelopes);
                    }
                    // Failed -- not retriable
                    return {
                        code: core.ExportResultCode.FAILED,
                    };
                }
                else {
                    // calls resultCallback(ExportResult) based on result of persister.push
                    return await this._persist(envelopes);
                }
            }
            else {
                // Failed -- not retriable
                return {
                    code: core.ExportResultCode.FAILED,
                };
            }
        }
        catch (error) {
            const restError = error;
            if (restError.statusCode &&
                (restError.statusCode === 307 || // Temporary redirect
                    restError.statusCode === 308)) {
                // Permanent redirect
                this._numConsecutiveRedirects++;
                // To prevent circular redirects
                if (this._numConsecutiveRedirects < 10) {
                    if (restError.response && restError.response.headers) {
                        const location = restError.response.headers.get("location");
                        if (location) {
                            // Update sender URL
                            this._sender.handlePermanentRedirect(location);
                            // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically
                            return this._exportEnvelopes(envelopes);
                        }
                    }
                }
                else {
                    return { code: core.ExportResultCode.FAILED, error: new Error("Circular redirect") };
                }
            }
            else if (restError.statusCode && isRetriable(restError.statusCode)) {
                return await this._persist(envelopes);
            }
            if (this._isNetworkError(restError)) {
                api.diag.error("Retrying due to transient client side error. Error message:", restError.message);
                return await this._persist(envelopes);
            }
            api.diag.error("Envelopes could not be exported and are not retriable. Error message:", restError.message);
            return { code: core.ExportResultCode.FAILED, error: restError };
        }
    }
    async _sendFirstPersistedFile() {
        try {
            const envelopes = (await this._persister.shift());
            if (envelopes) {
                await this._sender.send(envelopes);
            }
        }
        catch (err) {
            api.diag.warn(`Failed to fetch persisted file`, err);
        }
    }
    _isNetworkError(error) {
        if (error && error.code && error.code === "REQUEST_SEND_ERROR") {
            return true;
        }
        return false;
    }
}

// Copyright (c) Microsoft Corporation.
function createTagsFromResource(resource) {
    const context = getInstance();
    const tags = Object.assign({}, context.tags);
    if (resource && resource.attributes) {
        const serviceName = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAME];
        const serviceNamespace = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_NAMESPACE];
        if (serviceName) {
            if (serviceNamespace) {
                tags[KnownContextTagKeys.AiCloudRole] = `${serviceNamespace}.${serviceName}`;
            }
            else {
                tags[KnownContextTagKeys.AiCloudRole] = String(serviceName);
            }
        }
        const serviceInstanceId = resource.attributes[semanticConventions.SemanticResourceAttributes.SERVICE_INSTANCE_ID];
        if (serviceInstanceId) {
            tags[KnownContextTagKeys.AiCloudRoleInstance] = String(serviceInstanceId);
        }
        else {
            tags[KnownContextTagKeys.AiCloudRoleInstance] = os__default["default"] && os__default["default"].hostname();
        }
        const endUserId = resource.attributes[semanticConventions.SemanticAttributes.ENDUSER_ID];
        if (endUserId) {
            tags[KnownContextTagKeys.AiUserId] = String(endUserId);
        }
    }
    return tags;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure SDK namespace.
 * @internal
 */
const AzNamespace = "az.namespace";
/**
 * Azure SDK Eventhub.
 * @internal
 */
const MicrosoftEventHub = "Microsoft.EventHub";
/**
 * Azure SDK message bus destination.
 * @internal
 */
const MessageBusDestination = "message_bus.destination";

// Copyright (c) Microsoft Corporation.
/**
 * Average span.links[].attributes.enqueuedTime
 */
const getTimeSinceEnqueued = (span) => {
    let countEnqueueDiffs = 0;
    let sumEnqueueDiffs = 0;
    const startTimeMs = core.hrTimeToMilliseconds(span.startTime);
    span.links.forEach(({ attributes }) => {
        const enqueuedTime = attributes === null || attributes === void 0 ? void 0 : attributes[ENQUEUED_TIME];
        if (enqueuedTime) {
            countEnqueueDiffs += 1;
            sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);
        }
    });
    return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
};
/**
 * Implementation of Mapping to Azure Monitor
 *
 * https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#mapping-to-azure-monitor-application-insights-telemetry
 * @internal
 */
const parseEventHubSpan = (span, baseData) => {
    const namespace = span.attributes[AzNamespace];
    const peerAddress = (span.attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME] ||
        span.attributes["peer.address"] ||
        "unknown").replace(/\/$/g, ""); // remove trailing "/"
    const messageBusDestination = (span.attributes[MessageBusDestination] || "unknown");
    switch (span.kind) {
        case api.SpanKind.CLIENT:
            baseData.type = namespace;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.PRODUCER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.CONSUMER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.source = `${peerAddress}/${messageBusDestination}`;
            baseData.measurements = Object.assign(Object.assign({}, baseData.measurements), { [TIME_SINCE_ENQUEUED]: getTimeSinceEnqueued(span) });
            break;
    }
};

// Copyright (c) Microsoft Corporation.
function createGenericTagsFromSpan(span) {
    const tags = createTagsFromResource(span.resource);
    tags[KnownContextTagKeys.AiOperationId] = span.spanContext().traceId;
    if (span.parentSpanId) {
        tags[KnownContextTagKeys.AiOperationParentId] = span.parentSpanId;
    }
    const httpUserAgent = span.attributes[semanticConventions.SemanticAttributes.HTTP_USER_AGENT];
    if (httpUserAgent) {
        // TODO: Not exposed in Swagger, need to update def
        tags["ai.user.userAgent"] = String(httpUserAgent);
    }
    return tags;
}
function createTagsFromSpan(span) {
    const tags = createGenericTagsFromSpan(span);
    if (span.kind === api.SpanKind.SERVER) {
        const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
        const httpClientIp = span.attributes[semanticConventions.SemanticAttributes.HTTP_CLIENT_IP];
        const netPeerIp = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
        if (httpMethod) {
            const httpRoute = span.attributes[semanticConventions.SemanticAttributes.HTTP_ROUTE];
            const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
            tags[KnownContextTagKeys.AiOperationName] = span.name; // Default
            if (httpRoute) {
                tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${httpRoute}`;
            }
            else if (httpUrl) {
                try {
                    let url$1 = new url.URL(String(httpUrl));
                    tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${url$1.pathname}`;
                }
                catch (ex) { }
            }
            if (httpClientIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(httpClientIp);
            }
            else if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
        else {
            tags[KnownContextTagKeys.AiOperationName] = span.name;
            if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
    }
    // TODO: Operation Name and Location IP TBD for non server spans
    return tags;
}
function createPropertiesFromSpanAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            if (!(key.startsWith("http.") ||
                key.startsWith("rpc.") ||
                key.startsWith("db.") ||
                key.startsWith("peer.") ||
                key.startsWith("message.") ||
                key.startsWith("messaging.") ||
                key.startsWith("enduser.") ||
                key.startsWith("net.") ||
                key.startsWith("exception.") ||
                key.startsWith("thread.") ||
                key.startsWith("faas.") ||
                key.startsWith("code."))) {
                properties[key] = attributes[key];
            }
        }
    }
    return properties;
}
function createPropertiesFromSpan(span) {
    const properties = createPropertiesFromSpanAttributes(span.attributes);
    const measurements = {};
    const links = span.links.map((link) => ({
        operation_Id: link.context.traceId,
        id: link.context.spanId,
    }));
    if (links.length > 0) {
        properties[MS_LINKS] = JSON.stringify(links);
    }
    return [properties, measurements];
}
function isSqlDB(dbSystem) {
    return (dbSystem === semanticConventions.DbSystemValues.DB2 ||
        dbSystem === semanticConventions.DbSystemValues.DERBY ||
        dbSystem === semanticConventions.DbSystemValues.MARIADB ||
        dbSystem === semanticConventions.DbSystemValues.MSSQL ||
        dbSystem === semanticConventions.DbSystemValues.ORACLE ||
        dbSystem === semanticConventions.DbSystemValues.SQLITE ||
        dbSystem === semanticConventions.DbSystemValues.OTHER_SQL ||
        dbSystem === semanticConventions.DbSystemValues.HSQLDB ||
        dbSystem === semanticConventions.DbSystemValues.H2);
}
function getUrl(span) {
    const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    if (httpMethod) {
        const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
            return String(httpUrl);
        }
        else {
            const httpScheme = span.attributes[semanticConventions.SemanticAttributes.HTTP_SCHEME];
            const httpTarget = span.attributes[semanticConventions.SemanticAttributes.HTTP_TARGET];
            if (httpScheme && httpTarget) {
                const httpHost = span.attributes[semanticConventions.SemanticAttributes.HTTP_HOST];
                if (httpHost) {
                    return `${httpScheme}://${httpHost}${httpTarget}`;
                }
                else {
                    const netPeerPort = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_PORT];
                    if (netPeerPort) {
                        const netPeerName = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME];
                        if (netPeerName) {
                            return `${httpScheme}://${netPeerName}:${netPeerPort}${httpTarget}`;
                        }
                        else {
                            const netPeerIp = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
                            if (netPeerIp) {
                                return `${httpScheme}://${netPeerIp}:${netPeerPort}${httpTarget}`;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}
function getDependencyTarget(span) {
    const peerService = span.attributes[semanticConventions.SemanticAttributes.PEER_SERVICE];
    const httpHost = span.attributes[semanticConventions.SemanticAttributes.HTTP_HOST];
    const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
    const netPeerName = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_NAME];
    const netPeerIp = span.attributes[semanticConventions.SemanticAttributes.NET_PEER_IP];
    if (peerService) {
        return String(peerService);
    }
    else if (httpHost) {
        return String(httpHost);
    }
    else if (httpUrl) {
        return String(httpUrl);
    }
    else if (netPeerName) {
        return String(netPeerName);
    }
    else if (netPeerIp) {
        return String(netPeerIp);
    }
    return "";
}
function createDependencyData(span) {
    const remoteDependencyData = {
        name: span.name,
        id: `${span.spanContext().spanId}`,
        success: span.status.code != api.SpanStatusCode.ERROR,
        resultCode: "0",
        type: "Dependency",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
    };
    if (span.kind === api.SpanKind.PRODUCER) {
        remoteDependencyData.type = DependencyTypes.QueueMessage;
    }
    if (span.kind === api.SpanKind.INTERNAL && span.parentSpanId) {
        remoteDependencyData.type = DependencyTypes.InProc;
    }
    const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    const dbSystem = span.attributes[semanticConventions.SemanticAttributes.DB_SYSTEM];
    const rpcSystem = span.attributes[semanticConventions.SemanticAttributes.RPC_SYSTEM];
    // HTTP Dependency
    if (httpMethod) {
        const httpUrl = span.attributes[semanticConventions.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
            try {
                let dependencyUrl = new url.URL(String(httpUrl));
                remoteDependencyData.name = `${httpMethod} ${dependencyUrl.pathname}`;
            }
            catch (ex) { }
        }
        remoteDependencyData.type = DependencyTypes.Http;
        remoteDependencyData.data = getUrl(span);
        const httpStatusCode = span.attributes[semanticConventions.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
            remoteDependencyData.resultCode = String(httpStatusCode);
        }
        let target = getDependencyTarget(span);
        if (target) {
            try {
                // Remove default port
                let portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/);
                let res = portRegex.exec(target);
                if (res != null) {
                    let protocol = res[1];
                    let port = res[3];
                    if ((protocol == "https" && port == ":443") || (protocol == "http" && port == ":80")) {
                        // Drop port
                        target = res[1] + res[2] + res[4];
                    }
                }
            }
            catch (ex) { }
            remoteDependencyData.target = `${target}`;
        }
    }
    // DB Dependency
    else if (dbSystem) {
        // TODO: Remove special logic when Azure UX supports OpenTelemetry dbSystem
        if (String(dbSystem) === semanticConventions.DbSystemValues.MYSQL) {
            remoteDependencyData.type = "mysql";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.POSTGRESQL) {
            remoteDependencyData.type = "postgresql";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.MONGODB) {
            remoteDependencyData.type = "mongodb";
        }
        else if (String(dbSystem) === semanticConventions.DbSystemValues.REDIS) {
            remoteDependencyData.type = "redis";
        }
        else if (isSqlDB(String(dbSystem))) {
            remoteDependencyData.type = "SQL";
        }
        else {
            remoteDependencyData.type = String(dbSystem);
        }
        const dbStatement = span.attributes[semanticConventions.SemanticAttributes.DB_STATEMENT];
        const dbOperation = span.attributes[semanticConventions.SemanticAttributes.DB_OPERATION];
        if (dbStatement) {
            remoteDependencyData.data = String(dbStatement);
        }
        else if (dbOperation) {
            remoteDependencyData.data = String(dbOperation);
        }
        let target = getDependencyTarget(span);
        const dbName = span.attributes[semanticConventions.SemanticAttributes.DB_NAME];
        if (target) {
            remoteDependencyData.target = dbName ? `${target}|${dbName}` : `${target}`;
        }
        else {
            remoteDependencyData.target = dbName ? `${dbName}` : `${dbSystem}`;
        }
    }
    // grpc Dependency
    else if (rpcSystem) {
        remoteDependencyData.type = DependencyTypes.Grpc;
        const grpcStatusCode = span.attributes[semanticConventions.SemanticAttributes.RPC_GRPC_STATUS_CODE];
        if (grpcStatusCode) {
            remoteDependencyData.resultCode = String(grpcStatusCode);
        }
        let target = getDependencyTarget(span);
        if (target) {
            remoteDependencyData.target = `${target}`;
        }
        else if (rpcSystem) {
            remoteDependencyData.target = String(rpcSystem);
        }
    }
    return remoteDependencyData;
}
function createRequestData(span) {
    const requestData = {
        id: `${span.spanContext().spanId}`,
        success: span.status.code != api.SpanStatusCode.ERROR,
        responseCode: "0",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
        source: undefined,
    };
    const httpMethod = span.attributes[semanticConventions.SemanticAttributes.HTTP_METHOD];
    const grpcStatusCode = span.attributes[semanticConventions.SemanticAttributes.RPC_GRPC_STATUS_CODE];
    if (httpMethod) {
        requestData.url = getUrl(span);
        const httpStatusCode = span.attributes[semanticConventions.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
            requestData.responseCode = String(httpStatusCode);
        }
    }
    else if (grpcStatusCode) {
        requestData.responseCode = String(grpcStatusCode);
    }
    return requestData;
}
/**
 * Span to Azure envelope parsing.
 * @internal
 */
function readableSpanToEnvelope(span, ikey) {
    let name;
    let baseType;
    const sampleRate = 100;
    let baseData;
    const time = new Date(core.hrTimeToMilliseconds(span.startTime));
    const instrumentationKey = ikey;
    const tags = createTagsFromSpan(span);
    const [properties, measurements] = createPropertiesFromSpan(span);
    switch (span.kind) {
        case api.SpanKind.CLIENT:
        case api.SpanKind.PRODUCER:
        case api.SpanKind.INTERNAL:
            name = "Microsoft.ApplicationInsights.RemoteDependency";
            baseType = "RemoteDependencyData";
            baseData = createDependencyData(span);
            break;
        case api.SpanKind.SERVER:
        case api.SpanKind.CONSUMER:
            name = "Microsoft.ApplicationInsights.Request";
            baseType = "RequestData";
            baseData = createRequestData(span);
            baseData.name = tags[KnownContextTagKeys.AiOperationName];
            break;
        default:
            // never
            api.diag.error(`Unsupported span kind ${span.kind}`);
            throw new Error(`Unsupported span kind ${span.kind}`);
    }
    // Azure SDK
    if (span.attributes[AzNamespace]) {
        if (span.kind === api.SpanKind.INTERNAL) {
            baseData.type = `${DependencyTypes.InProc} | ${span.attributes[AzNamespace]}`;
        }
        if (span.attributes[AzNamespace] === MicrosoftEventHub) {
            parseEventHubSpan(span, baseData);
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: Object.assign(Object.assign({}, baseData), { properties,
                measurements }),
        },
    };
}
/**
 * Span Events to Azure envelopes parsing.
 * @internal
 */
function spanEventsToEnvelopes(span, ikey) {
    let envelopes = [];
    if (span.events) {
        span.events.forEach((event) => {
            let baseType;
            const sampleRate = 100;
            let time = new Date(core.hrTimeToMilliseconds(event.time));
            let name = "";
            let baseData;
            const properties = createPropertiesFromSpanAttributes(event.attributes);
            const tags = createGenericTagsFromSpan(span);
            if (event.name == "exception") {
                name = "Microsoft.ApplicationInsights.Exception";
                baseType = "ExceptionData";
                let typeName = "";
                let message = "Exception";
                let stack = "";
                let hasFullStack = false;
                if (event.attributes) {
                    typeName = String(event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_TYPE]);
                    stack = String(event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_STACKTRACE]);
                    if (stack) {
                        hasFullStack = true;
                    }
                    let exceptionMsg = event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_MESSAGE];
                    if (exceptionMsg) {
                        message = String(exceptionMsg);
                    }
                    let escaped = event.attributes[semanticConventions.SemanticAttributes.EXCEPTION_ESCAPED];
                    if (escaped != undefined) {
                        properties[semanticConventions.SemanticAttributes.EXCEPTION_ESCAPED] = String(escaped);
                    }
                }
                let exceptionDetails = {
                    typeName: typeName,
                    message: message,
                    stack: stack,
                    hasFullStack: hasFullStack,
                };
                let exceptionData = {
                    exceptions: [exceptionDetails],
                    version: 2,
                    properties: properties,
                };
                baseData = exceptionData;
            }
            else {
                name = "Microsoft.ApplicationInsights.Message";
                baseType = "MessageData";
                let messageData = {
                    message: event.name,
                    version: 2,
                    properties: properties,
                };
                baseData = messageData;
            }
            let env = {
                name: name,
                time: time,
                instrumentationKey: ikey,
                version: 1,
                sampleRate: sampleRate,
                data: {
                    baseType: baseType,
                    baseData: baseData,
                },
                tags: tags,
            };
            envelopes.push(env);
        });
    }
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorTraceExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorTraceExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        api.diag.debug("AzureMonitorTraceExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry spans.
     * @param spans - Spans to export.
     * @param resultCallback - Result callback.
     */
    async export(spans, resultCallback) {
        api.diag.info(`Exporting ${spans.length} span(s). Converting to envelopes...`);
        let envelopes = [];
        spans.forEach((span) => {
            envelopes.push(readableSpanToEnvelope(span, this._instrumentationKey));
            let spanEventEnvelopes = spanEventsToEnvelopes(span, this._instrumentationKey);
            if (spanEventEnvelopes.length > 0) {
                envelopes.push(...spanEventEnvelopes);
            }
        });
        resultCallback(await this._exportEnvelopes(envelopes));
    }
    /**
     * Shutdown AzureMonitorTraceExporter.
     */
    async shutdown() {
        api.diag.info("Azure Monitor Trace Exporter shutting down");
        return this._shutdown();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Metric to Azure envelope parsing.
 * @internal
 */
function resourceMetricsToEnvelope(metrics, ikey) {
    let envelopes = [];
    const time = new Date();
    const instrumentationKey = ikey;
    const tags = createTagsFromResource(metrics.resource);
    metrics.scopeMetrics.forEach((scopeMetric) => {
        let baseData = {
            metrics: [],
            version: 2,
        };
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                var metricDataPoint = {
                    name: metric.descriptor.name,
                    value: 0,
                    dataPointType: "Aggregation",
                };
                if (metric.dataPointType == sdkMetricsBase.DataPointType.SINGULAR) {
                    metricDataPoint.value = dataPoint.value;
                    metricDataPoint.count = 1;
                }
                else {
                    metricDataPoint.value = dataPoint.value.sum;
                    metricDataPoint.count = dataPoint.value.count;
                }
                baseData.metrics.push(metricDataPoint);
            });
        });
        let envelope = {
            name: "Microsoft.ApplicationInsights.Metric",
            time: time,
            sampleRate: 100,
            instrumentationKey: instrumentationKey,
            tags: tags,
            version: 1,
            data: {
                baseType: "MetricData",
                baseData: Object.assign({}, baseData),
            },
        };
        envelopes.push(envelope);
    });
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
/**
 * Azure Monitor OpenTelemetry Metric Exporter.
 */
class AzureMonitorMetricExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorMetricExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        api.diag.debug("AzureMonitorMetricExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry resource metrics.
     * @param metrics - Resource metrics to export.
     * @param resultCallback - Result callback.
     */
    async export(metrics, resultCallback) {
        api.diag.info(`Exporting ${metrics.scopeMetrics.length} metrics(s). Converting to envelopes...`);
        let envelopes = resourceMetricsToEnvelope(metrics, this._instrumentationKey);
        resultCallback(await this._exportEnvelopes(envelopes));
    }
    /**
     * Shutdown AzureMonitorMetricExporter.
     */
    async shutdown() {
        api.diag.info("Azure Monitor Trace Exporter shutting down");
        return this._shutdown();
    }
    /**
     * Select aggregation temporality
     */
    selectAggregationTemporality() {
        return sdkMetricsBase.AggregationTemporality.CUMULATIVE;
    }
    /**
     * Force flush
     */
    async forceFlush() {
        // TODO: https://github.com/open-telemetry/opentelemetry-js/issues/3060
        throw new Error("Method not implemented.");
    }
}

exports.AzureMonitorBaseExporter = AzureMonitorBaseExporter;
exports.AzureMonitorMetricExporter = AzureMonitorMetricExporter;
exports.AzureMonitorTraceExporter = AzureMonitorTraceExporter;
//# sourceMappingURL=index.js.map
